/** THIS FILE IS AUTOMATICALLY GENERATED FROM : https://www.bitmex.com/api/explorer/swagger.json **/

// tslint:disable:max-line-length

/**
 * Public Announcements
 */
export interface Announcement {
    id: number; // format: int32
    link: string;
    title: string;
    content: string;
    date: string; // format: date-time
}

export interface Error {
    error: any;
}

/**
 * Persistent API Keys for Developers
 */
export interface APIKey {
    id: string; // maxLength: 24
    secret: string; // maxLength: 48
    name: string; // maxLength: 64
    nonce: number; // format: int64
    cidr: string; // maxLength: 18
    cidrs: any[]; // default: []
    targetAccountId: number; // format: int32
    permissions: any[]; // default: []
    enabled: boolean;
    userId: number; // format: int32
    created: string; // format: date-time
}

/**
 * Pinned Messages
 */
export interface PinnedMessage {
    id: number; // format: int32
    channelID: number; // format: int32
    messageId: number; // format: int32
    created: string; // format: date-time
    ended: string; // format: date-time
    createdUserId: number; // format: double
    endedUserId: number; // format: double
}

/**
 * Trollbox Data
 */
export interface Chat {
    id: number; // format: int32
    date: string; // format: date-time
    user: string;
    userColor: string;
    message: string;
    html: string;
    channelID: number; // format: double
}

export interface ChatChannel {
    id: number; // format: int32
    name: string;
    isPrivate: boolean;
}

export interface ConnectedUsers {
    users: number; // format: int32
    bots: number; // format: int32
}

/**
 * Raw Order and Balance Data
 */
export interface Execution {
    execID: string; // format: guid
    orderID: string; // format: guid
    clOrdID: string;
    clOrdLinkID: string;
    account: number; // format: int64
    symbol: string;
    side: string;
    lastQty: number; // format: int64
    lastPx: number; // format: double
    lastLiquidityInd: string;
    orderQty: number; // format: int64
    price: number; // format: double
    displayQty: number; // format: int64
    stopPx: number; // format: double
    pegOffsetValue: number; // format: double
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    execType: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    leavesQty: number; // format: int64
    cumQty: number; // format: int64
    avgPx: number; // format: double
    commission: number; // format: double
    brokerCommission: number; // format: double
    feeType: string;
    tradePublishIndicator: string;
    text: string;
    trdMatchID: string; // format: guid
    execCost: number; // format: int64
    execComm: number; // format: int64
    brokerExecComm: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
    transactTime: string; // format: date-time
    timestamp: string; // format: date-time
    realisedPnl: number; // format: int64
    trdType: string;
}

/**
 * Swap Funding History
 */
export interface Funding {
    timestamp: string; // format: date-time
    symbol: string;
    fundingInterval: string; // format: date-time
    fundingRate: number; // format: double
    fundingRateDaily: number; // format: double
}

/**
 * Tradeable Contracts, Indices, and History
 */
export interface Instrument {
    symbol: string;
    rootSymbol: string;
    state: string;
    typ: string;
    listing: string; // format: date-time
    front: string; // format: date-time
    expiry: string; // format: date-time
    settle: string; // format: date-time
    listedSettle: string; // format: date-time
    positionCurrency: string;
    underlying: string;
    quoteCurrency: string;
    underlyingSymbol: string;
    reference: string;
    referenceSymbol: string;
    calcInterval: string; // format: date-time
    publishInterval: string; // format: date-time
    publishTime: string; // format: date-time
    maxOrderQty: number; // format: int64
    maxPrice: number; // format: double
    lotSize: number; // format: int64
    tickSize: number; // format: double
    multiplier: number; // format: int64
    settlCurrency: string;
    underlyingToPositionMultiplier: number; // format: int64
    underlyingToSettleMultiplier: number; // format: int64
    quoteToSettleMultiplier: number; // format: int64
    isQuanto: boolean;
    isInverse: boolean;
    initMargin: number; // format: double
    maintMargin: number; // format: double
    riskLimit: number; // format: int64
    riskStep: number; // format: int64
    limit: number; // format: double
    taxed: boolean;
    deleverage: boolean;
    makerFee: number; // format: double
    takerFee: number; // format: double
    settlementFee: number; // format: double
    fundingBaseSymbol: string;
    fundingQuoteSymbol: string;
    fundingPremiumSymbol: string;
    fundingTimestamp: string; // format: date-time
    fundingInterval: string; // format: date-time
    fundingRate: number; // format: double
    indicativeFundingRate: number; // format: double
    rebalanceTimestamp: string; // format: date-time
    rebalanceInterval: string; // format: date-time
    prevClosePrice: number; // format: double
    limitDownPrice: number; // format: double
    limitUpPrice: number; // format: double
    totalVolume: number; // format: int64
    volume: number; // format: int64
    volume24h: number; // format: int64
    prevTotalTurnover: number; // format: int64
    totalTurnover: number; // format: int64
    turnover: number; // format: int64
    turnover24h: number; // format: int64
    homeNotional24h: number; // format: double
    foreignNotional24h: number; // format: double
    prevPrice24h: number; // format: double
    vwap: number; // format: double
    highPrice: number; // format: double
    lowPrice: number; // format: double
    lastPrice: number; // format: double
    lastPriceProtected: number; // format: double
    lastTickDirection: string;
    lastChangePcnt: number; // format: double
    bidPrice: number; // format: double
    midPrice: number; // format: double
    askPrice: number; // format: double
    impactBidPrice: number; // format: double
    impactMidPrice: number; // format: double
    impactAskPrice: number; // format: double
    hasLiquidity: boolean;
    openInterest: number; // format: int64
    openValue: number; // format: int64
    fairMethod: string;
    fairBasisRate: number; // format: double
    fairBasis: number; // format: double
    fairPrice: number; // format: double
    markMethod: string;
    markPrice: number; // format: double
    indicativeSettlePrice: number; // format: double
    settledPriceAdjustmentRate: number; // format: double
    settledPrice: number; // format: double
    instantPnl: boolean;
    minTick: number; // format: double
    fundingBaseRate: number; // format: double
    fundingQuoteRate: number; // format: double
    timestamp: string; // format: date-time
}

export interface InstrumentInterval {
    intervals: string[];
    symbols: string[];
}

export interface IndexComposite {
    timestamp: string; // format: date-time
    symbol: string;
    indexSymbol: string;
    indexMultiplier: number; // format: double
    reference: string;
    lastPrice: number; // format: double
    sourcePrice: number; // format: double
    conversionIndex: string;
    conversionIndexPrice: number; // format: double
    weight: number; // format: double
    logged: string; // format: date-time
}

export interface StatsUSDBySymbol {
    symbol: string;
    currency: string;
    turnover24h: number; // format: int64
    turnover30d: number; // format: int64
    turnover365d: number; // format: int64
    turnover: number; // format: int64
}

/**
 * Insurance Fund Data
 */
export interface Insurance {
    currency: string;
    timestamp: string; // format: date-time
    walletBalance: number; // format: int64
}

/**
 * Information on Top Users
 */
export interface Leaderboard {
    name: string;
    isRealName: boolean;
    profit: number; // format: double
}

/**
 * Active Liquidations
 */
export interface Liquidation {
    orderID: string; // format: guid
    symbol: string;
    side: string;
    price: number; // format: double
    leavesQty: number; // format: int64
}

/**
 * Account Notifications
 */
export interface GlobalNotification {
    id: number; // format: int32
    date: string; // format: date-time
    title: string;
    body: string;
    ttl: number; // format: int32
    type: 'success' | 'error' | 'info';
    closable: boolean; // default: true
    persist: boolean; // default: true
    waitForVisibility: boolean; // default: true
    sound: string;
}

/**
 * Placement, Cancellation, Amending, and History
 */
export interface Order {
    price: number; // format: double
    ordType: string;
    clOrdID: string;
    stopPx: number; // format: double
    workingIndicator: boolean;
    clOrdLinkID: string;
    pegOffsetValue: number; // format: double
    cumQty: number; // format: int64
    avgPx: number; // format: double
    execInst: string;
    symbol: string;
    triggered: string;
    timestamp: string; // format: date-time
    settlCurrency: string;
    side: string;
    leavesQty: number; // format: int64
    contingencyType: string;
    pegPriceType: string;
    orderQty: number; // format: int64
    account: number; // format: int64
    orderID: string; // format: guid
    ordStatus: string;
    timeInForce: string;
    currency: string;
    text: string;
    displayQty: number; // format: int64
    ordRejReason: string;
    transactTime: string; // format: date-time
}

export interface OrderBookL2 {
    symbol: string;
    id: number; // format: int64
    side: string;
    size: number; // format: int64
    price: number; // format: double
    timestamp: string; // format: date-time
    transactTime: string; // format: date-time
}

/**
 * Summary of Open and Closed Positions
 */
export interface Position {
    account: number; // format: int64
    symbol: string;
    currency: string;
    underlying: string;
    quoteCurrency: string;
    commission: number; // format: double
    initMarginReq: number; // format: double
    maintMarginReq: number; // format: double
    riskLimit: number; // format: int64
    leverage: number; // format: double
    crossMargin: boolean;
    deleveragePercentile: number; // format: double
    rebalancedPnl: number; // format: int64
    prevRealisedPnl: number; // format: int64
    prevUnrealisedPnl: number; // format: int64
    openingQty: number; // format: int64
    openOrderBuyQty: number; // format: int64
    openOrderBuyCost: number; // format: int64
    openOrderBuyPremium: number; // format: int64
    openOrderSellQty: number; // format: int64
    openOrderSellCost: number; // format: int64
    openOrderSellPremium: number; // format: int64
    currentQty: number; // format: int64
    currentCost: number; // format: int64
    currentComm: number; // format: int64
    realisedCost: number; // format: int64
    unrealisedCost: number; // format: int64
    grossOpenPremium: number; // format: int64
    isOpen: boolean;
    markPrice: number; // format: double
    markValue: number; // format: int64
    riskValue: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
    posState: string;
    posCost: number; // format: int64
    posCross: number; // format: int64
    posComm: number; // format: int64
    posLoss: number; // format: int64
    posMargin: number; // format: int64
    posMaint: number; // format: int64
    initMargin: number; // format: int64
    maintMargin: number; // format: int64
    realisedPnl: number; // format: int64
    unrealisedPnl: number; // format: int64
    unrealisedPnlPcnt: number; // format: double
    unrealisedRoePcnt: number; // format: double
    avgCostPrice: number; // format: double
    avgEntryPrice: number; // format: double
    breakEvenPrice: number; // format: double
    marginCallPrice: number; // format: double
    liquidationPrice: number; // format: double
    bankruptPrice: number; // format: double
    timestamp: string; // format: date-time
}

/**
 * Best Bid/Offer Snapshots & Historical Bins
 */
export interface Quote {
    timestamp: string; // format: date-time
    symbol: string;
    bidSize: number; // format: int64
    bidPrice: number; // format: double
    askPrice: number; // format: double
    askSize: number; // format: int64
}

/**
 * Historical Settlement Data
 */
export interface Settlement {
    timestamp: string; // format: date-time
    symbol: string;
    settlementType: string;
    settledPrice: number; // format: double
    optionStrikePrice: number; // format: double
    optionUnderlyingPrice: number; // format: double
    bankrupt: number; // format: int64
    taxBase: number; // format: int64
    taxRate: number; // format: double
}

/**
 * Exchange Statistics
 */
export interface Stats {
    rootSymbol: string;
    currency: string;
    volume24h: number; // format: int64
    turnover24h: number; // format: int64
    openInterest: number; // format: int64
    openValue: number; // format: int64
}

export interface StatsHistory {
    date: string; // format: date-time
    rootSymbol: string;
    currency: string;
    volume: number; // format: int64
    turnover: number; // format: int64
}

export interface StatsUSD {
    rootSymbol: string;
    currency: string;
    turnover24h: number; // format: int64
    turnover30d: number; // format: int64
    turnover365d: number; // format: int64
    turnover: number; // format: int64
}

/**
 * Individual & Bucketed Trades
 */
export interface Trade {
    timestamp: string; // format: date-time
    symbol: string;
    side: string;
    size: number; // format: int64
    price: number; // format: double
    tickDirection: string;
    trdMatchID: string; // format: guid
    grossValue: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
    trdType: string;
}

export interface TradeBin {
    timestamp: string; // format: date-time
    symbol: string;
    open: number; // format: double
    high: number; // format: double
    low: number; // format: double
    close: number; // format: double
    trades: number; // format: int64
    volume: number; // format: int64
    vwap: number; // format: double
    lastSize: number; // format: int64
    turnover: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
}

/**
 * Deposit Address
 */
export interface DepositAddress {
    address: string;
    memo: string;
}

/**
 * Assets and Networks Data
 */
export interface Wallet {
    account: number; // format: int64
    currency: string;
    deposited: number; // format: int64
    withdrawn: number; // format: int64
    transferIn: number; // format: int64
    transferOut: number; // format: int64
    amount: number; // format: int64
    pendingCredit: number; // format: int64
    pendingDebit: number; // format: int64
    confirmedDebit: number; // format: int64
    timestamp: string; // format: date-time
}

export interface Transaction {
    transactID: string; // format: guid
    account: number; // format: int64
    currency: string;
    network: string;
    transactType: string;
    amount: number; // format: int64
    walletBalance: number; // format: int64
    fee: number; // format: int64
    transactStatus: string;
    address: string;
    tx: string;
    orderID: string; // format: guid
    text: string;
    transactTime: string; // format: date-time
    timestamp: string; // format: date-time
    memo: string;
}

export interface WalletSummaryRecord {
    account: number; // format: double
    currency: string; // default: XBt
    transactType: string;
    symbol: string; // default: XBTUSD
    amount: number; // format: double
    pendingDebit: number; // format: double
    realisedPnl: number; // format: double
    walletBalance: number; // format: double
    unrealisedPnl: number; // format: double
    marginBalance: number; // format: double
}

/**
 * Get the current user staking amount in vertical format.
 */
export interface StakingRecord {
    account: number; // format: double
    amount: number; // format: double
    currency: string; // default: XBt
}

export interface AccessToken {
    updated: string; // format: date-time
    authorizedAccounts: any; // default: {"margin":{"read":[]},"order":{"read":[],"write":[]},"execution":{"read":[]},"position":{"read":[]},"internalTransfer":{"write":[]},"transferTakeover":{"write":[]},"owner":[]}
    id: string;
    ttl: number; // format: double, default: 1209600
    created: string; // format: date-time
    userId: number; // format: double
}

export interface Affiliate {
    account: number; // format: int64
    currency: string;
    prevPayout: number; // format: int64
    prevTurnover: number; // format: int64
    prevComm: number; // format: int64
    prevTimestamp: string; // format: date-time
    execTurnover: number; // format: int64
    execComm: number; // format: int64
    totalReferrals: number; // format: int64
    totalTurnover: number; // format: int64
    totalComm: number; // format: int64
    payoutPcnt: number; // format: double
    pendingPayout: number; // format: int64
    timestamp: string; // format: date-time
    referrerAccount: number; // format: double
    referralDiscount: number; // format: double
    affiliatePayout: number; // format: double
}

/**
 * Daily Quote Fill Ratio Statistic
 */
export interface QuoteFillRatio {
    date: string; // format: date-time
    account: number; // format: double
    quoteCount: number; // format: double
    dealtCount: number; // format: double
    quotesMavg7: number; // format: double
    dealtMavg7: number; // format: double
    quoteFillRatioMavg7: number; // format: double
}

/**
 * Hourly Quote Value Ratio Statistic
 */
export interface QuoteValueRatio {
    timestamp: string; // format: date-time
    account: number; // format: double
    symbol: string;
    quoteCount: number; // format: double
    volumeXBT: number; // format: double
    QVR: number; // format: double
    id: number; // format: double
}

/**
 * 30 days USD average trading volume
 */
export interface TradingVolume {
    advUsd: number; // format: double
    advUsdSpot: number; // format: double
    advUsdContract: number; // format: double
}

/**
 * Account Operations
 */
export interface User {
    id: number; // format: int32
    firstname: string;
    lastname: string;
    username: string;
    accountName: string;
    isUser: boolean; // default: true
    email: string;
    dateOfBirth: string;
    phone: string;
    created: string; // format: date-time
    lastUpdated: string; // format: date-time
    preferences: UserPreferences; // default: {}
    TFAEnabled: string;
    affiliateID: string; // maxLength: 6
    country: string; // maxLength: 3
    geoipCountry: string; // maxLength: 2
    geoipRegion: string; // maxLength: 2
    firstTradeTimestamp: string; // format: date-time
    firstDepositTimestamp: string; // format: date-time
    isElite: boolean;
    typ: string;
}

/**
 * Account information
 */
export interface Account {
    account: number; // format: int64
    state: string;
    typ: string;
    settlementFeeDiscount: number; // format: double
    insuranceFeeDiscount: number; // format: double
    referralDiscount: number; // format: double
    referrerAccount: number; // format: int64
    affiliatePayout: number; // format: double
    affiliateDiscount: number; // format: double
    isSuspended: boolean;
    marginingMode: string;
    timeoutTimestamp: string; // format: date-time
    makerFeeDiscount: number; // format: double
    takerFeeDiscount: number; // format: double
    timestamp: string; // format: date-time
}

export interface UserCommissionsBySymbol {
}

export interface Margin {
    account: number; // format: int64
    currency: string;
    riskLimit: number; // format: int64
    state: string;
    amount: number; // format: int64
    prevRealisedPnl: number; // format: int64
    grossComm: number; // format: int64
    grossOpenCost: number; // format: int64
    grossOpenPremium: number; // format: int64
    grossExecCost: number; // format: int64
    grossMarkValue: number; // format: int64
    riskValue: number; // format: int64
    initMargin: number; // format: int64
    maintMargin: number; // format: int64
    targetExcessMargin: number; // format: int64
    realisedPnl: number; // format: int64
    unrealisedPnl: number; // format: int64
    walletBalance: number; // format: int64
    marginBalance: number; // format: int64
    marginLeverage: number; // format: double
    marginUsedPcnt: number; // format: double
    excessMargin: number; // format: int64
    availableMargin: number; // format: int64
    withdrawableMargin: number; // format: int64
    makerFeeDiscount: number; // format: double
    takerFeeDiscount: number; // format: double
    timestamp: string; // format: date-time
    foreignMarginBalance: number; // format: int64
    foreignRequirement: number; // format: int64
}

export interface CollateralSupportAgreement {
    csaID: string;
    account: number; // format: int64
    currency: string;
    amount: number; // format: int64
    minAmount: number; // format: int64
    threshold: number; // format: int64
    mmRatioMarginCall: number; // format: int64
    mmRatioLiquidation: number; // format: int64
    startTime: string;
    maturityTime: string;
    maturityInstruction: string;
    csaStatus: string;
    requester: string;
    clientDetails: string;
    text: string;
    timestamp: string;
}

/**
 * User communication SNS token
 */
export interface CommunicationToken {
    id: string;
    userId: number; // format: int32
    deviceToken: string;
    channel: string;
}

/**
 * User Events for Auditing
 */
export interface UserEvent {
    id: number; // format: double
    type: 'apiKeyCreated' | 'deleverageExecution' | 'depositConfirmed' | 'depositPending' | 'banZeroVolumeApiUser' | 'liquidationOrderPlaced' | 'login' | 'existingAccountRegistrationAttempt' | 'passwordChanged' | 'positionStateLiquidated' | 'positionStateWarning' | 'resetPasswordConfirmed' | 'resetPasswordRequest' | 'tradingBotStopped' | 'transferCanceled' | 'transferCompleted' | 'transferReceived' | 'transferRequested' | 'twoFactorDisabled' | 'twoFactorEnabled' | 'withdrawalCanceled' | 'withdrawalCompleted' | 'withdrawalConfirmed' | 'withdrawalRequested' | 'addressCreated' | 'addressRemoved' | 'addressVerified' | 'addressSkipConfirmRequested' | 'addressSkipConfirmVerified' | 'addressCooldownUpdated' | 'addressConfigUpdated' | 'verify' | 'restrictedAccount' | 'unrestrictedAccount' | 'disabledAccount' | 'enabledAccount' | 'role:roleMappingDestroy' | 'role:chatBanned' | 'role:withdrawalBanned' | 'role:orderBanned' | 'role:apiBanned' | 'role:restrictedJurisdictionPrivilege';
    status: 'success' | 'failure';
    userId: number; // format: double
    createdById: number; // format: double
    ip: string;
    geoipCountry: string; // maxLength: 2
    geoipRegion: string; // maxLength: 3
    geoipSubRegion: string; // maxLength: 3
    eventMeta: any;
    created: string; // format: date-time
}

export interface AssetsConfig {
    asset: string; // default: XBT
    currency: string; // default: XBt
    majorCurrency: string; // default: XBT
    name: string; // default: Bitcoin
    currencyType: string; // default: Crypto
    scale: number; // format: double, default: 8
    enabled: boolean; // default: true
    isMarginCurrency: boolean; // default: true
    memoRequired: boolean;
    networks: AssetsConfigNetworkItem[];
}

export interface NetworksConfig {
    network: string; // default: eth
    name: string; // default: Ethereum
    currency: string; // default: Gwei
    networkSymbol: string; // default: ETH
    transactionExplorer: string; // default: https://etherscan.io/tx/
    tokenExplorer: string; // default: https://etherscan.io/token/
    depositConfirmations: number; // format: int32
    enabled: boolean; // default: true
}

export interface Address {
    id: number; // format: int32
    currency: string;
    created: string; // format: date-time
    userId: number; // format: double
    address: string;
    name: string;
    note: string;
    skipConfirm: boolean;
    skipConfirmVerified: boolean;
    skip2FA: boolean;
    skip2FAVerified: boolean;
    network: string;
    memo: string;
    cooldownExpires: string; // format: date-time
    verified: boolean;
}

export interface AddressConfig {
    id: number; // format: int32
    whitelist: boolean;
    created: string; // format: date-time
    disabled: string; // format: date-time
    userId: number; // format: double
    defaultCooldown: number; // format: double
    frozen: boolean;
}

export interface Guild {
    id: number; // format: int32
    created: string; // format: date-time
    updated: string; // format: date-time
    archived: boolean;
    name: string;
    imgUrl: string;
    mobileHeroImgUrl: string;
    emoji: string;
    logoUrl: string;
    description: string;
    chatChannelId: number; // format: double
    isPrivate: boolean;
    affiliateId: string;
    potDistributionPreferences: any;
    socials: any;
    deleted: boolean;
}

/**
 * Proof of Reserves/Liabilities
 */
export interface Porl {
    account: number; // format: int32
    nonce: string;
    accountNonce: string;
    total: number; // format: double
    balance: number; // format: double
    filename: string;
    height: number; // format: double
    created: string; // format: date-time
}

export interface ReferralCode {
    id: string;
    userId: number; // format: double
    code: string;
    details: any; // default: {}
    created: string; // format: date-time
    modified: string; // format: date-time
    isDefault: boolean;
    isPrimary: boolean;
}

export interface UserPreferences {
    alertOnLiquidations: boolean;
    animationsEnabled: boolean;
    announcementsLastSeen: string; // format: date-time
    botsAdvancedMode: boolean;
    botVideosHidden: boolean;
    chatChannelID: number; // format: double
    colorTheme: string;
    currency: string;
    debug: boolean;
    disableEmails: string[];
    disablePush: string[];
    displayCorpEnrollUpsell: boolean;
    equivalentCurrency: string;
    features: string[];
    favourites: string[];
    favouritesAssets: string[];
    favouritesOrdered: string[];
    favouriteBots: string[];
    favouriteContracts: string[];
    hasSetTradingCurrencies: boolean;
    hideConfirmDialogs: string[];
    hideConnectionModal: boolean;
    hideFromLeaderboard: boolean;
    hideNameFromLeaderboard: boolean;
    hidePnlInGuilds: boolean;
    hideRoiInGuilds: boolean;
    hideNotifications: string[];
    hidePhoneConfirm: boolean;
    guidesShownVersion: number; // format: int32
    isSensitiveInfoVisible: boolean;
    isWalletZeroBalanceHidden: boolean;
    locale: string; // default: en-US
    localeSetTime: number; // format: double
    marginPnlRow: string;
    marginPnlRowKind: string;
    mobileLocale: string;
    msgsSeen: string[];
    notifications: any;
    optionsBeta: boolean;
    orderBookBinning: any;
    orderBookType: string;
    orderClearImmediate: boolean;
    orderControlsPlusMinus: boolean;
    orderInputType: string;
    platformLayout: string;
    selectedFiatCurrency: string;
    showChartBottomToolbar: boolean;
    showLocaleNumbers: boolean; // default: true
    sounds: string[];
    spacingPreference: string;
    strictIPCheck: boolean;
    strictTimeout: boolean; // default: true
    tickerGroup: string;
    tickerPinned: boolean;
    tradeLayout: string;
    userColor: string;
    videosSeen: string[];
}

export interface AssetsConfigNetworkItem {
    asset: string; // default: BTC
    tokenAddress: string;
    depositEnabled: boolean; // default: true
    withdrawalEnabled: boolean; // default: true
    withdrawalFee: number; // format: double
    minFee: number; // format: double
    maxFee: number; // format: double
}

export interface AnnouncementQuery {

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     */
    columns?: string;
}

export interface ApiKeyQuery {

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false
}

export interface ChatPinnedQuery {

    channelID: number;
}

export interface ChatQuery {

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting ID for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: true

    /**
     * Channel id. GET /chat/channels for ids. Global English by default
     */
    channelID?: number; // DEFAULT: 1
}

export interface ChatPost {

    message: string;

    /**
     * Channel to post to. Default 1 (English).
     */
    channelID?: number; // DEFAULT: 1
}

export interface ExecutionQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface ExecutionTradeHistoryQuery {

    /**
     * AccountId fetching the trade history, must be a paired account with main user.
     */
    targetAccountId?: number;

    /**
     * AccountIds fetching the trade history, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountIds?: string;

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface FundingQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InstrumentQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InstrumentCompositeIndexQuery {

    /**
     * The composite index symbol.
     */
    symbol?: string; // DEFAULT: .BXBT

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InstrumentUsdVolumeQuery {

    /**
     * Filter by symbol.
     */
    symbol?: string;

    /**
     * Array of column names to fetch.
     */
    columns?: string;
}

export interface InsuranceQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    currency?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface LeaderboardQuery {

    /**
     * Ranking type. Options: "notional", "ROE"
     */
    method?: 'notional' | 'ROE'; // DEFAULT: notional
}

export interface LiquidationQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface OrderQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface OrderPost {

    /**
     * Instrument symbol. e.g. 'XBTUSD'.
     */
    symbol: string;

    /**
     * Order side. Valid options: Buy, Sell. Defaults to 'Buy' unless `orderQty` is negative.
     */
    side?: 'Buy' | 'Sell';

    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;

    /**
     * Order quantity in units of the instrument (i.e. contracts, for spot it is base currency in minor currency for spot (e.g. XBt quantity for XBT)).
     */
    orderQty?: number;

    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;

    /**
     * Optional quantity to display in the book. Use 0 for a fully hidden order.
     */
    displayQty?: number;

    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use `execInst` of 'MarkPrice' or 'LastPrice' to define the current price used for triggering.
     */
    stopPx?: number;

    /**
     * Optional Client Order ID. This clOrdID will come back on the order and any related executions.
     */
    clOrdID?: string;

    /**
     * Optional Client Order Link ID for contingent orders
     */
    clOrdLinkID?: string;

    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;

    /**
     * Optional peg price type. Valid options: MarketPeg, PrimaryPeg, TrailingStopPeg.
     */
    pegPriceType?: 'MarketPeg' | 'PrimaryPeg' | 'TrailingStopPeg';

    /**
     * Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, Pegged. Defaults to 'Limit' when `price` is specified. Defaults to 'Stop' when `stopPx` is specified. Defaults to 'StopLimit' when `price` and `stopPx` are specified.
     */
    ordType?: 'Market' | 'Limit' | 'Stop' | 'StopLimit' | 'MarketIfTouched' | 'LimitIfTouched' | 'Pegged'; // DEFAULT: Limit

    /**
     * Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to 'GoodTillCancel' for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    timeInForce?: 'Day' | 'GoodTillCancel' | 'ImmediateOrCancel' | 'FillOrKill';

    /**
     * Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed, LastWithinMark. 'AllOrNone' instruction requires `displayQty` to be 0. 'MarkPrice', 'IndexPrice' or 'LastPrice' instruction valid for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. 'LastWithinMark' instruction valid for 'Stop' and 'StopLimit' with instruction 'LastPrice'. IndexPrice, LastWithMark, Close and ReduceOnly are not applicable to spot trading symbols.
     */
    execInst?: 'ParticipateDoNotInitiate' | 'AllOrNone' | 'MarkPrice' | 'IndexPrice' | 'LastPrice' | 'Close' | 'ReduceOnly' | 'Fixed' | 'LastWithinMark';

    /**
     * Optional contingency type for use with `clOrdLinkID`. Valid options: OneCancelsTheOther, OneTriggersTheOther.
     */
    contingencyType?: 'OneCancelsTheOther' | 'OneTriggersTheOther';

    /**
     * Optional order annotation. e.g. 'Take profit'.
     */
    text?: string;
}

export interface OrderPut {

    /**
     * Order ID
     */
    orderID?: string;

    /**
     * Client Order ID. See POST /order.
     */
    origClOrdID?: string;

    /**
     * Optional new Client Order ID, requires `origClOrdID`.
     */
    clOrdID?: string;

    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;

    /**
     * Optional order quantity in units of the instrument (i.e. contracts, for spot it is the base currency in minor currency (e.g. XBt quantity for XBT)).
     */
    orderQty?: number;

    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleLeavesQty?: number;

    /**
     * Optional leaves quantity in units of the instrument (i.e. contracts, for spot it is the base currency in minor currency (e.g. XBt quantity for XBT)). Useful for amending partially filled orders.
     */
    leavesQty?: number;

    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;

    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders.
     */
    stopPx?: number;

    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;

    /**
     * Optional amend annotation. e.g. 'Adjust skew'.
     */
    text?: string;
}

export interface OrderDelete {

    /**
     * Order ID(s).
     */
    orderID?: string;

    /**
     * Client Order ID(s). See POST /order.
     */
    clOrdID?: string;

    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'.
     */
    text?: string;
}

export interface OrderClosePositionPost {

    /**
     * Symbol of position to close.
     */
    symbol: string;

    /**
     * Optional limit price.
     */
    price?: number;
}

export interface OrderAllDelete {

    /**
     * AccountIds to cancel all orders, must be a paired account with main user. Also accepts wildcard, [*], this will cancel all orders for all accounts. the authenticated user has order write permissions for.
     */
    targetAccountIds?: string;

    /**
     * Optional symbol. If provided, only cancels orders for that symbol.
     */
    symbol?: string;

    /**
     * Optional filter for cancellation. Use to only cancel some orders, e.g. `{"side": "Buy"}`.
     */
    filter?: string;

    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'
     */
    text?: string;
}

export interface OrderCancelAllAfterPost {

    /**
     * Timeout in ms. Set to 0 to cancel this timer.
     */
    timeout: number;
}

export interface OrderBookL2Query {

    /**
     * Instrument symbol. Send a series (e.g. XBT) to get data for the nearest contract in that series.
     */
    symbol: string;

    /**
     * Orderbook depth per side. Send 0 for full depth.
     */
    depth?: number; // DEFAULT: 25
}

export interface PositionQuery {

    /**
     * Table filter. For example, send {"symbol": "XBTUSD"}.
     */
    filter?: string;

    /**
     * Which columns to fetch. For example, send ["columnName"].
     */
    columns?: string;

    /**
     * Number of rows to fetch.
     */
    count?: number;
}

export interface PositionIsolatePost {

    /**
     * Position symbol to isolate.
     */
    symbol: string;

    /**
     * True for isolated margin, false for cross margin.
     */
    enabled?: boolean; // DEFAULT: true
}

export interface PositionRiskLimitPost {

    /**
     * Symbol of position to update risk limit on.
     */
    symbol: string;

    /**
     * New Risk Limit, in Satoshis.
     */
    riskLimit: number;

    /**
     * AccountId for the position that the risk limit would be updated on, must be a paired account with main user.
     */
    targetAccountId?: number;
}

export interface PositionTransferMarginPost {

    /**
     * Symbol of position to isolate.
     */
    symbol: string;

    /**
     * Amount to transfer, in Satoshis. May be negative.
     */
    amount: number;

    /**
     * AccountId for the position that the margin would be transfered to, must be a paired account with main user.
     */
    targetAccountId?: number;
}

export interface PositionLeveragePost {

    /**
     * Symbol of position to adjust.
     */
    symbol: string;

    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;

    /**
     * AccountId for the position that the leverage would be changed on, must be a paired account with main user.
     */
    targetAccountId?: number;
}

export interface PositionCrossLeveragePost {

    /**
     * Symbol of position to adjust.
     */
    symbol: string;

    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;

    /**
     * AccountId for the position that the leverage would be changed on, must be a paired account with main user.
     */
    targetAccountId?: number;
}

export interface QuoteQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface QuoteBucketedQuery {

    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d'; // DEFAULT: 1m

    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean; // DEFAULT: false

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface SchemaQuery {

    /**
     * Optional model filter. If omitted, will return all models.
     */
    model?: string;
}

export interface SettlementQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface TradeQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface TradeBucketedQuery {

    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d'; // DEFAULT: 1m

    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean; // DEFAULT: false

    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface UserDepositAddressQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;

    /**
     * The `network` parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /wallet/assets`.
     */
    network: string;
}

export interface UserDepositAddressInformationQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;

    /**
     * The `network` parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /wallet/assets`.
     */
    network: string;
}

export interface UserWalletQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string; // DEFAULT: XBt
}

export interface UserWalletHistoryQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string; // DEFAULT: XBt

    /**
     * Number of results to fetch. Fetch results from start to start + count. Max: 10,000 rows.
     */
    count?: number; // DEFAULT: 10000

    /**
     * Starting point for results, integer. Default 0.
     */
    start?: number; // DEFAULT: 0

    /**
     * AccountId to view the history of, must be a paired account with the authorised user requesting the history.
     */
    targetAccountId?: number;

    /**
     * Start from the latest transaction record. Default true.
     */
    reverse?: boolean; // DEFAULT: true
}

export interface UserWalletSummaryQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string; // DEFAULT: XBt

    /**
     * Start time for the summary
     */
    startTime?: string;

    /**
     * End time for the summary
     */
    endTime?: string;
}

export interface UserExecutionHistoryQuery {

    symbol?: string; // DEFAULT: XBTUSD

    timestamp?: string; // DEFAULT: 2017-02-13T12:00:00.000Z
}

export interface UserStakingQuery {

    currency?: string;
}

export interface UserUnstakingRequestsQuery {

    status: string;
}

export interface UserUnstakingRequestsPost {

    symbol: string;

    amount: number;
}

export interface UserUnstakingRequestsDelete {

    redemptionID: string;
}

export interface UserStakingInstrumentsQuery {

    symbol?: string;

    currency?: string;
}

export interface UserStakingTiersQuery {

    currency: string;
}

export interface UserWalletTransferPost {

    /**
     * Currency you're transfering. Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;

    /**
     * Amount of transfer.
     */
    amount: number;

    /**
     * AccountID to send the transfer from. Must be paired account with the authenticated user.
     */
    fromAccountId?: number;

    /**
     * AccountId to send the transfer to, must be a paired account with the user sending the transfer.
     */
    targetAccountId: number;
}

export interface UserRequestWithdrawalPost {

    /**
     * 2FA token. Required for all external withdrawals unless the destination is a saved address with `skip2FA` configured.
     */
    otpToken?: string;

    /**
     * Currency you're withdrawing. Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency?: string; // DEFAULT: XBt

    /**
     * The `network` parameter is used to indicate which blockchain you would like to withdraw from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /api/v1/wallet/assets`.
     */
    network: string;

    /**
     * Amount of withdrawal currency.
     */
    amount: number;

    /**
     * Destination Address. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    address?: string;

    /**
     * Destination Memo. If `address`, is specified, destination Memo can also be specified. If given an `addressId` or `address` matching a saved address, the destination memo from the saved address will be used.
     */
    memo?: string;

    /**
     * ID of the Destination Address. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    addressId?: number;

    /**
     * ID of a linked BitMEX account. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    targetUserId?: number;

    /**
     * Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email.
     */
    fee?: number;

    /**
     * Optional annotation, e.g. 'Transfer to home wallet'.
     */
    text?: string;
}

export interface UserWithdrawalDelete {

    transactID: string;
}

export interface UserCancelWithdrawalPost {

    token: string;
}

export interface UserConfirmWithdrawalPost {

    token: string;
}

export interface UserConfirmEmailPost {

    token: string;
}

export interface UserAffiliateStatusQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string; // DEFAULT: XBt
}

export interface UserCheckReferralCodeQuery {

    referralCode?: string;
}

export interface UserQuoteFillRatioQuery {

    /**
     * AccountId to get quote fill ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountId?: number;
}

export interface UserQuoteValueRatioQuery {

    /**
     * AccountId to get quote value ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountId?: number;
}

export interface UserAddSubaccountPost {

    accountName: string;
}

export interface UserCreateIndependentSubaccountPost {

    email: string;

    accountName: string;
}

export interface UserUpdateSubaccountPost {

    targetAccountId: number;

    accountName: string;
}

export interface UserPreferencesPost {

    prefs: string;

    /**
     * If true, will overwrite all existing preferences.
     */
    overwrite?: boolean; // DEFAULT: false
}

export interface UserMarginingModePost {

    /**
     * AccountId to update the margining mode of.
     */
    targetAccountId?: number;

    /**
     * Margining mode. Provide the value MultiAsset for multi-asset margining. Leave the field empty for single-asset margining
     */
    marginingMode?: string;
}

export interface UserMarginQuery {

    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string; // DEFAULT: XBt
}

export interface UserCommunicationTokenPost {

    token: string;

    platformAgent: string;
}

export interface UserEventQuery {

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Cursor for pagination.
     */
    startId?: number;
}

export interface AddressPost {

    /**
     * Currency of the address. Options: `XBt`, `USDt`
     */
    currency?: 'XBt' | 'USDt';

    /**
     * Selected network.
     */
    network: string;

    /**
     * Destination Address.
     */
    address: string;

    /**
     * Name of the entry, eg. 'Hardware wallet'.
     */
    name: string;

    /**
     * Optional annotation.
     */
    note?: string;

    /**
     * Skip e-mail confirmations for transfers to this address. An email will be sent for confirmation to verify this setting.
     */
    skipConfirm?: boolean; // DEFAULT: false

    /**
     * Skip 2FA confirmations for transfers to this address. If otpToken is not provided in this request, an email will be sent to capture 2FA and verify this setting.
     */
    skip2FA?: boolean; // DEFAULT: false

    /**
     * Destination Memo.
     */
    memo?: string;

    /**
     * 2FA token. Provide to verify skip2FA or to start the cooldown period on address with whitelist setting enabled. If not provided, an email will be sent to capture 2FA.
     */
    otpToken?: string;
}

export interface UserAffiliatesQuery {

    /**
     * the depth of affiliates to return. Eg depth = 2 would return direct affiliates and their affiliates
     */
    depth?: number;

    /**
     * AccountId of Sub-Affiliate Account
     */
    targetAccountId?: number;

    /**
     * User id of result array to keep
     */
    selectUserId?: number;
}

export interface GuildPost {

    /**
     * Name of the guild, must be unique, must be at least 5 characters
     */
    name: string;

    /**
     * Emoji name.
     */
    emoji: string;

    /**
     * How much of the pot should be distributed to the guild members, must be between 0 and 100
     */
    potDistributionPercent: number;

    /**
     * How the pot should be distributed to the guild members, must be one of the following: ROLL_OVER, TOP_3, TOP_5, TOP_10, VOLUME_PERCENTAGE, TOP_3_BY_ADV, TOP_5_BY_ADV, TOP_10_BY_ADV, TOP_3_BY_ROI, TOP_5_BY_ROI, TOP_10_BY_ROI, RANDOM
     */
    potDistributionType: string;

    /**
     * Guild description, can be used to explain the guild to other users.
     */
    description?: string;

    /**
     * Guild twitter handle.
     */
    twitter?: string;

    /**
     * Guild discord link.
     */
    discord?: string;

    /**
     * Guild telegram link.
     */
    telegram?: string;

    /**
     * URL for the profile image of the guild, is used by clients to add some color to the guild, if no image is provided, a default image is used
     */
    imgUrl?: string;

    /**
     * Guild privacy status
     */
    isPrivate?: boolean;
}

export interface GuildPut {

    /**
     * Name of the guild, must be unique, must be at least 5 characters
     */
    name: string;

    /**
     * Emoji name.
     */
    emoji: string;

    /**
     * How much of the pot should be distributed to the guild members, must be between 0 and 100
     */
    potDistributionPercent: number;

    /**
     * How the pot should be distributed to the guild members, must be one of the following: ROLL_OVER, TOP_3, TOP_5, TOP_10, VOLUME_PERCENTAGE, TOP_3_BY_ADV, TOP_5_BY_ADV, TOP_10_BY_ADV, TOP_3_BY_ROI, TOP_5_BY_ROI, TOP_10_BY_ROI, RANDOM
     */
    potDistributionType: string;

    /**
     * User ID of the guild member with order write permission for the pot
     */
    potTraderId?: number;

    /**
     * Guild description, can be used to explain the guild to other users.
     */
    description?: string;

    /**
     * Guild twitter handle.
     */
    twitter?: string;

    /**
     * Guild discord link.
     */
    discord?: string;

    /**
     * Guild telegram link.
     */
    telegram?: string;

    /**
     * URL for the profile image of the guild, is used by clients to add some color to the guild, if no image is provided, a default image is used
     */
    imgUrl?: string;

    /**
     * Guild privacy status
     */
    isPrivate?: boolean;
}

export interface GuildShareTradesPost {

    shareTrades: boolean;
}

export interface GuildKickPost {

    memberUserId: number;
}

export interface GuildJoinPost {

    code: string;
}

export interface ReferralCodePost {

    data: undefined;
}

export interface ReferralCodeCheckGet {

    code: string;
}

export interface ReferralCodePut {

    id: number;

    data: undefined;
}

export interface ReferralCodeDelete {

    id: number;
}

export interface ReferralCodeGet {

    id: number;
}
