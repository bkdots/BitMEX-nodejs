/** THIS FILE IS AUTOMATICALLY GENERATED FROM : https://www.bitmex.com/api/explorer/swagger.json **/
/**
 * Public Announcements
 */
export interface Announcement {
    id: number;
    link: string;
    title: string;
    content: string;
    date: string;
}
export interface Error {
    error: any;
}
/**
 * Persistent API Keys for Developers
 */
export interface APIKey {
    id: string;
    secret: string;
    name: string;
    nonce: number;
    cidr: string;
    cidrs: any[];
    targetAccountId: number;
    permissions: any[];
    enabled: boolean;
    userId: number;
    created: string;
}
/**
 * Pinned Messages
 */
export interface PinnedMessage {
    id: number;
    channelID: number;
    messageId: number;
    created: string;
    ended: string;
    createdUserId: number;
    endedUserId: number;
}
/**
 * Trollbox Data
 */
export interface Chat {
    id: number;
    date: string;
    user: string;
    userColor: string;
    message: string;
    html: string;
    channelID: number;
}
export interface ChatChannel {
    id: number;
    name: string;
    isPrivate: boolean;
}
export interface ConnectedUsers {
    users: number;
    bots: number;
}
/**
 * Raw Order and Balance Data
 */
export interface Execution {
    execID: string;
    orderID: string;
    clOrdID: string;
    clOrdLinkID: string;
    account: number;
    symbol: string;
    side: string;
    lastQty: number;
    lastPx: number;
    lastLiquidityInd: string;
    orderQty: number;
    price: number;
    displayQty: number;
    stopPx: number;
    pegOffsetValue: number;
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    execType: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    leavesQty: number;
    cumQty: number;
    avgPx: number;
    commission: number;
    brokerCommission: number;
    feeType: string;
    tradePublishIndicator: string;
    text: string;
    trdMatchID: string;
    execCost: number;
    execComm: number;
    brokerExecComm: number;
    homeNotional: number;
    foreignNotional: number;
    transactTime: string;
    timestamp: string;
    realisedPnl: number;
    trdType: string;
}
/**
 * Swap Funding History
 */
export interface Funding {
    timestamp: string;
    symbol: string;
    fundingInterval: string;
    fundingRate: number;
    fundingRateDaily: number;
}
/**
 * Tradeable Contracts, Indices, and History
 */
export interface Instrument {
    symbol: string;
    rootSymbol: string;
    state: string;
    typ: string;
    listing: string;
    front: string;
    expiry: string;
    settle: string;
    listedSettle: string;
    positionCurrency: string;
    underlying: string;
    quoteCurrency: string;
    underlyingSymbol: string;
    reference: string;
    referenceSymbol: string;
    calcInterval: string;
    publishInterval: string;
    publishTime: string;
    maxOrderQty: number;
    maxPrice: number;
    lotSize: number;
    tickSize: number;
    multiplier: number;
    settlCurrency: string;
    underlyingToPositionMultiplier: number;
    underlyingToSettleMultiplier: number;
    quoteToSettleMultiplier: number;
    isQuanto: boolean;
    isInverse: boolean;
    initMargin: number;
    maintMargin: number;
    riskLimit: number;
    riskStep: number;
    limit: number;
    taxed: boolean;
    deleverage: boolean;
    makerFee: number;
    takerFee: number;
    settlementFee: number;
    fundingBaseSymbol: string;
    fundingQuoteSymbol: string;
    fundingPremiumSymbol: string;
    fundingTimestamp: string;
    fundingInterval: string;
    fundingRate: number;
    indicativeFundingRate: number;
    rebalanceTimestamp: string;
    rebalanceInterval: string;
    prevClosePrice: number;
    limitDownPrice: number;
    limitUpPrice: number;
    totalVolume: number;
    volume: number;
    volume24h: number;
    prevTotalTurnover: number;
    totalTurnover: number;
    turnover: number;
    turnover24h: number;
    homeNotional24h: number;
    foreignNotional24h: number;
    prevPrice24h: number;
    vwap: number;
    highPrice: number;
    lowPrice: number;
    lastPrice: number;
    lastPriceProtected: number;
    lastTickDirection: string;
    lastChangePcnt: number;
    bidPrice: number;
    midPrice: number;
    askPrice: number;
    impactBidPrice: number;
    impactMidPrice: number;
    impactAskPrice: number;
    hasLiquidity: boolean;
    openInterest: number;
    openValue: number;
    fairMethod: string;
    fairBasisRate: number;
    fairBasis: number;
    fairPrice: number;
    markMethod: string;
    markPrice: number;
    indicativeSettlePrice: number;
    settledPriceAdjustmentRate: number;
    settledPrice: number;
    instantPnl: boolean;
    minTick: number;
    fundingBaseRate: number;
    fundingQuoteRate: number;
    timestamp: string;
}
export interface InstrumentInterval {
    intervals: string[];
    symbols: string[];
}
export interface IndexComposite {
    timestamp: string;
    symbol: string;
    indexSymbol: string;
    indexMultiplier: number;
    reference: string;
    lastPrice: number;
    sourcePrice: number;
    conversionIndex: string;
    conversionIndexPrice: number;
    weight: number;
    logged: string;
}
export interface StatsUSDBySymbol {
    symbol: string;
    currency: string;
    turnover24h: number;
    turnover30d: number;
    turnover365d: number;
    turnover: number;
}
/**
 * Insurance Fund Data
 */
export interface Insurance {
    currency: string;
    timestamp: string;
    walletBalance: number;
}
/**
 * Information on Top Users
 */
export interface Leaderboard {
    name: string;
    isRealName: boolean;
    profit: number;
}
/**
 * Active Liquidations
 */
export interface Liquidation {
    orderID: string;
    symbol: string;
    side: string;
    price: number;
    leavesQty: number;
}
/**
 * Account Notifications
 */
export interface GlobalNotification {
    id: number;
    date: string;
    title: string;
    body: string;
    ttl: number;
    type: 'success' | 'error' | 'info';
    closable: boolean;
    persist: boolean;
    waitForVisibility: boolean;
    sound: string;
}
/**
 * Placement, Cancellation, Amending, and History
 */
export interface Order {
    currency: string;
    timeInForce: string;
    ordStatus: string;
    orderID: string;
    account: number;
    orderQty: number;
    pegPriceType: string;
    contingencyType: string;
    leavesQty: number;
    side: string;
    settlCurrency: string;
    timestamp: string;
    triggered: string;
    symbol: string;
    execInst: string;
    avgPx: number;
    cumQty: number;
    pegOffsetValue: number;
    clOrdLinkID: string;
    workingIndicator: boolean;
    stopPx: number;
    clOrdID: string;
    ordType: string;
    price: number;
    transactTime: string;
    ordRejReason: string;
    displayQty: number;
    text: string;
}
export interface OrderBookL2 {
    symbol: string;
    id: number;
    side: string;
    size: number;
    price: number;
    timestamp: string;
    transactTime: string;
}
/**
 * Summary of Open and Closed Positions
 */
export interface Position {
    account: number;
    symbol: string;
    currency: string;
    underlying: string;
    quoteCurrency: string;
    commission: number;
    initMarginReq: number;
    maintMarginReq: number;
    riskLimit: number;
    leverage: number;
    crossMargin: boolean;
    deleveragePercentile: number;
    rebalancedPnl: number;
    prevRealisedPnl: number;
    prevUnrealisedPnl: number;
    openingQty: number;
    openOrderBuyQty: number;
    openOrderBuyCost: number;
    openOrderBuyPremium: number;
    openOrderSellQty: number;
    openOrderSellCost: number;
    openOrderSellPremium: number;
    currentQty: number;
    currentCost: number;
    currentComm: number;
    realisedCost: number;
    unrealisedCost: number;
    grossOpenPremium: number;
    isOpen: boolean;
    markPrice: number;
    markValue: number;
    riskValue: number;
    homeNotional: number;
    foreignNotional: number;
    posState: string;
    posCost: number;
    posCross: number;
    posComm: number;
    posLoss: number;
    posMargin: number;
    posMaint: number;
    initMargin: number;
    maintMargin: number;
    realisedPnl: number;
    unrealisedPnl: number;
    unrealisedPnlPcnt: number;
    unrealisedRoePcnt: number;
    avgCostPrice: number;
    avgEntryPrice: number;
    breakEvenPrice: number;
    marginCallPrice: number;
    liquidationPrice: number;
    bankruptPrice: number;
    timestamp: string;
}
/**
 * Best Bid/Offer Snapshots & Historical Bins
 */
export interface Quote {
    timestamp: string;
    symbol: string;
    bidSize: number;
    bidPrice: number;
    askPrice: number;
    askSize: number;
}
/**
 * Historical Settlement Data
 */
export interface Settlement {
    timestamp: string;
    symbol: string;
    settlementType: string;
    settledPrice: number;
    optionStrikePrice: number;
    optionUnderlyingPrice: number;
    bankrupt: number;
    taxBase: number;
    taxRate: number;
}
/**
 * Exchange Statistics
 */
export interface Stats {
    rootSymbol: string;
    currency: string;
    volume24h: number;
    turnover24h: number;
    openInterest: number;
    openValue: number;
}
export interface StatsHistory {
    date: string;
    rootSymbol: string;
    currency: string;
    volume: number;
    turnover: number;
}
export interface StatsUSD {
    rootSymbol: string;
    currency: string;
    turnover24h: number;
    turnover30d: number;
    turnover365d: number;
    turnover: number;
}
/**
 * Individual & Bucketed Trades
 */
export interface Trade {
    timestamp: string;
    symbol: string;
    side: string;
    size: number;
    price: number;
    tickDirection: string;
    trdMatchID: string;
    grossValue: number;
    homeNotional: number;
    foreignNotional: number;
    trdType: string;
}
export interface TradeBin {
    timestamp: string;
    symbol: string;
    open: number;
    high: number;
    low: number;
    close: number;
    trades: number;
    volume: number;
    vwap: number;
    lastSize: number;
    turnover: number;
    homeNotional: number;
    foreignNotional: number;
}
/**
 * Deposit Address
 */
export interface DepositAddress {
    address: string;
    memo: string;
}
/**
 * Assets and Networks Data
 */
export interface Wallet {
    account: number;
    currency: string;
    deposited: number;
    withdrawn: number;
    transferIn: number;
    transferOut: number;
    amount: number;
    pendingCredit: number;
    pendingDebit: number;
    confirmedDebit: number;
    timestamp: string;
}
export interface Transaction {
    transactID: string;
    account: number;
    currency: string;
    network: string;
    transactType: string;
    amount: number;
    walletBalance: number;
    fee: number;
    transactStatus: string;
    address: string;
    tx: string;
    orderID: string;
    text: string;
    transactTime: string;
    timestamp: string;
    memo: string;
}
export interface WalletSummaryRecord {
    account: number;
    currency: string;
    transactType: string;
    symbol: string;
    amount: number;
    pendingDebit: number;
    realisedPnl: number;
    walletBalance: number;
    unrealisedPnl: number;
    marginBalance: number;
}
/**
 * Get the current user staking amount in vertical format.
 */
export interface StakingRecord {
    account: number;
    amount: number;
    currency: string;
}
export interface AccessToken {
    updated: string;
    authorizedAccounts: any;
    id: string;
    ttl: number;
    created: string;
    userId: number;
}
export interface Affiliate {
    account: number;
    currency: string;
    prevPayout: number;
    prevTurnover: number;
    prevComm: number;
    prevTimestamp: string;
    execTurnover: number;
    execComm: number;
    totalReferrals: number;
    totalTurnover: number;
    totalComm: number;
    payoutPcnt: number;
    pendingPayout: number;
    timestamp: string;
    referrerAccount: number;
    referralDiscount: number;
    affiliatePayout: number;
}
/**
 * Daily Quote Fill Ratio Statistic
 */
export interface QuoteFillRatio {
    date: string;
    account: number;
    quoteCount: number;
    dealtCount: number;
    quotesMavg7: number;
    dealtMavg7: number;
    quoteFillRatioMavg7: number;
}
/**
 * Hourly Quote Value Ratio Statistic
 */
export interface QuoteValueRatio {
    timestamp: string;
    account: number;
    symbol: string;
    quoteCount: number;
    volumeXBT: number;
    QVR: number;
    id: number;
}
/**
 * 30 days USD average trading volume
 */
export interface TradingVolume {
    advUsd: number;
    advUsdSpot: number;
    advUsdContract: number;
}
/**
 * Account Operations
 */
export interface User {
    id: number;
    firstname: string;
    lastname: string;
    username: string;
    accountName: string;
    isUser: boolean;
    email: string;
    dateOfBirth: string;
    phone: string;
    created: string;
    lastUpdated: string;
    preferences: UserPreferences;
    TFAEnabled: string;
    affiliateID: string;
    country: string;
    geoipCountry: string;
    geoipRegion: string;
    firstTradeTimestamp: string;
    firstDepositTimestamp: string;
    isElite: boolean;
    typ: string;
}
/**
 * Account information
 */
export interface Account {
    account: number;
    state: string;
    typ: string;
    settlementFeeDiscount: number;
    insuranceFeeDiscount: number;
    referralDiscount: number;
    referrerAccount: number;
    affiliatePayout: number;
    affiliateDiscount: number;
    isSuspended: boolean;
    marginingMode: string;
    timeoutTimestamp: string;
    makerFeeDiscount: number;
    takerFeeDiscount: number;
    timestamp: string;
}
export interface UserCommissionsBySymbol {
}
export interface Margin {
    account: number;
    currency: string;
    riskLimit: number;
    state: string;
    amount: number;
    prevRealisedPnl: number;
    grossComm: number;
    grossOpenCost: number;
    grossOpenPremium: number;
    grossExecCost: number;
    grossMarkValue: number;
    riskValue: number;
    initMargin: number;
    maintMargin: number;
    targetExcessMargin: number;
    realisedPnl: number;
    unrealisedPnl: number;
    walletBalance: number;
    marginBalance: number;
    marginLeverage: number;
    marginUsedPcnt: number;
    excessMargin: number;
    availableMargin: number;
    withdrawableMargin: number;
    makerFeeDiscount: number;
    takerFeeDiscount: number;
    timestamp: string;
    foreignMarginBalance: number;
    foreignRequirement: number;
}
export interface CollateralSupportAgreement {
    csaID: string;
    account: number;
    currency: string;
    amount: number;
    minAmount: number;
    threshold: number;
    mmRatioMarginCall: number;
    mmRatioLiquidation: number;
    startTime: string;
    maturityTime: string;
    maturityInstruction: string;
    csaStatus: string;
    requester: string;
    clientDetails: string;
    text: string;
    timestamp: string;
}
/**
 * User communication SNS token
 */
export interface CommunicationToken {
    id: string;
    userId: number;
    deviceToken: string;
    channel: string;
}
/**
 * User Events for Auditing
 */
export interface UserEvent {
    id: number;
    type: 'apiKeyCreated' | 'deleverageExecution' | 'depositConfirmed' | 'depositPending' | 'banZeroVolumeApiUser' | 'liquidationOrderPlaced' | 'login' | 'existingAccountRegistrationAttempt' | 'passwordChanged' | 'positionStateLiquidated' | 'positionStateWarning' | 'resetPasswordConfirmed' | 'resetPasswordRequest' | 'tradingBotStopped' | 'transferCanceled' | 'transferCompleted' | 'transferReceived' | 'transferRequested' | 'twoFactorDisabled' | 'twoFactorEnabled' | 'withdrawalCanceled' | 'withdrawalCompleted' | 'withdrawalConfirmed' | 'withdrawalRequested' | 'addressCreated' | 'addressRemoved' | 'addressVerified' | 'addressSkipConfirmRequested' | 'addressSkipConfirmVerified' | 'addressCooldownUpdated' | 'addressConfigUpdated' | 'verify' | 'restrictedAccount' | 'unrestrictedAccount' | 'disabledAccount' | 'enabledAccount' | 'role:roleMappingDestroy' | 'role:chatBanned' | 'role:withdrawalBanned' | 'role:orderBanned' | 'role:apiBanned' | 'role:restrictedJurisdictionPrivilege';
    status: 'success' | 'failure';
    userId: number;
    createdById: number;
    ip: string;
    geoipCountry: string;
    geoipRegion: string;
    geoipSubRegion: string;
    eventMeta: any;
    created: string;
}
export interface AssetsConfig {
    asset: string;
    currency: string;
    majorCurrency: string;
    name: string;
    currencyType: string;
    scale: number;
    enabled: boolean;
    isMarginCurrency: boolean;
    memoRequired: boolean;
    networks: AssetsConfigNetworkItem[];
}
export interface NetworksConfig {
    network: string;
    name: string;
    currency: string;
    networkSymbol: string;
    transactionExplorer: string;
    tokenExplorer: string;
    depositConfirmations: number;
    enabled: boolean;
}
export interface Address {
    id: number;
    currency: string;
    created: string;
    userId: number;
    address: string;
    name: string;
    note: string;
    skipConfirm: boolean;
    skipConfirmVerified: boolean;
    skip2FA: boolean;
    skip2FAVerified: boolean;
    network: string;
    memo: string;
    cooldownExpires: string;
    verified: boolean;
}
export interface AddressConfig {
    id: number;
    whitelist: boolean;
    created: string;
    disabled: string;
    userId: number;
    defaultCooldown: number;
    frozen: boolean;
}
export interface Guild {
    id: number;
    created: string;
    updated: string;
    archived: boolean;
    name: string;
    imgUrl: string;
    mobileHeroImgUrl: string;
    emoji: string;
    logoUrl: string;
    description: string;
    chatChannelId: number;
    isPrivate: boolean;
    affiliateId: string;
    potDistributionPreferences: any;
    socials: any;
    deleted: boolean;
}
/**
 * Proof of Reserves/Liabilities
 */
export interface Porl {
    account: number;
    nonce: string;
    accountNonce: string;
    total: number;
    balance: number;
    filename: string;
    height: number;
    created: string;
}
export interface ReferralCode {
    id: string;
    userId: number;
    code: string;
    details: any;
    created: string;
    modified: string;
    isDefault: boolean;
    isPrimary: boolean;
}
export interface UserPreferences {
    alertOnLiquidations: boolean;
    animationsEnabled: boolean;
    announcementsLastSeen: string;
    botsAdvancedMode: boolean;
    botVideosHidden: boolean;
    chatChannelID: number;
    colorTheme: string;
    currency: string;
    debug: boolean;
    disableEmails: string[];
    disablePush: string[];
    displayCorpEnrollUpsell: boolean;
    equivalentCurrency: string;
    features: string[];
    favourites: string[];
    favouritesAssets: string[];
    favouritesOrdered: string[];
    favouriteBots: string[];
    favouriteContracts: string[];
    hasSetTradingCurrencies: boolean;
    hideConfirmDialogs: string[];
    hideConnectionModal: boolean;
    hideFromLeaderboard: boolean;
    hideNameFromLeaderboard: boolean;
    hidePnlInGuilds: boolean;
    hideRoiInGuilds: boolean;
    hideNotifications: string[];
    hidePhoneConfirm: boolean;
    guidesShownVersion: number;
    isSensitiveInfoVisible: boolean;
    isWalletZeroBalanceHidden: boolean;
    locale: string;
    localeSetTime: number;
    marginPnlRow: string;
    marginPnlRowKind: string;
    mobileLocale: string;
    msgsSeen: string[];
    notifications: any;
    optionsBeta: boolean;
    orderBookBinning: any;
    orderBookType: string;
    orderClearImmediate: boolean;
    orderControlsPlusMinus: boolean;
    orderInputType: string;
    platformLayout: string;
    selectedFiatCurrency: string;
    showChartBottomToolbar: boolean;
    showLocaleNumbers: boolean;
    sounds: string[];
    spacingPreference: string;
    strictIPCheck: boolean;
    strictTimeout: boolean;
    tickerGroup: string;
    tickerPinned: boolean;
    tradeLayout: string;
    userColor: string;
    videosSeen: string[];
}
export interface AssetsConfigNetworkItem {
    asset: string;
    tokenAddress: string;
    depositEnabled: boolean;
    withdrawalEnabled: boolean;
    withdrawalFee: number;
    minFee: number;
    maxFee: number;
}
export interface AnnouncementQuery {
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     */
    columns?: string;
}
export interface ApiKeyQuery {
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
}
export interface ChatPinnedQuery {
    channelID: number;
}
export interface ChatQuery {
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting ID for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Channel id. GET /chat/channels for ids. Global English by default
     */
    channelID?: number;
}
export interface ChatPost {
    message: string;
    /**
     * Channel to post to. Default 1 (English).
     */
    channelID?: number;
}
export interface ExecutionQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface ExecutionTradeHistoryQuery {
    /**
     * AccountId fetching the trade history, must be a paired account with main user.
     */
    targetAccountId?: number;
    /**
     * AccountIds fetching the trade history, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountIds?: string;
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface FundingQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InstrumentQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InstrumentCompositeIndexQuery {
    /**
     * The composite index symbol.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InstrumentUsdVolumeQuery {
    /**
     * Filter by symbol.
     */
    symbol?: string;
    /**
     * Array of column names to fetch.
     */
    columns?: string;
}
export interface InsuranceQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    currency?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface LeaderboardQuery {
    /**
     * Ranking type. Options: "notional", "ROE"
     */
    method?: 'notional' | 'ROE';
}
export interface LiquidationQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface OrderQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface OrderPost {
    /**
     * Instrument symbol. e.g. 'XBTUSD'.
     */
    symbol: string;
    /**
     * Order side. Valid options: Buy, Sell. Defaults to 'Buy' unless `orderQty` is negative.
     */
    side?: 'Buy' | 'Sell';
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;
    /**
     * Order quantity in units of the instrument (i.e. contracts, for spot it is base currency in minor currency for spot (e.g. XBt quantity for XBT)).
     */
    orderQty?: number;
    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;
    /**
     * Optional quantity to display in the book. Use 0 for a fully hidden order.
     */
    displayQty?: number;
    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use `execInst` of 'MarkPrice' or 'LastPrice' to define the current price used for triggering.
     */
    stopPx?: number;
    /**
     * Optional Client Order ID. This clOrdID will come back on the order and any related executions.
     */
    clOrdID?: string;
    /**
     * Optional Client Order Link ID for contingent orders
     */
    clOrdLinkID?: string;
    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;
    /**
     * Optional peg price type. Valid options: MarketPeg, PrimaryPeg, TrailingStopPeg.
     */
    pegPriceType?: 'MarketPeg' | 'PrimaryPeg' | 'TrailingStopPeg';
    /**
     * Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, Pegged. Defaults to 'Limit' when `price` is specified. Defaults to 'Stop' when `stopPx` is specified. Defaults to 'StopLimit' when `price` and `stopPx` are specified.
     */
    ordType?: 'Market' | 'Limit' | 'Stop' | 'StopLimit' | 'MarketIfTouched' | 'LimitIfTouched' | 'Pegged';
    /**
     * Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to 'GoodTillCancel' for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    timeInForce?: 'Day' | 'GoodTillCancel' | 'ImmediateOrCancel' | 'FillOrKill';
    /**
     * Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed, LastWithinMark. 'AllOrNone' instruction requires `displayQty` to be 0. 'MarkPrice', 'IndexPrice' or 'LastPrice' instruction valid for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. 'LastWithinMark' instruction valid for 'Stop' and 'StopLimit' with instruction 'LastPrice'. IndexPrice, LastWithMark, Close and ReduceOnly are not applicable to spot trading symbols.
     */
    execInst?: 'ParticipateDoNotInitiate' | 'AllOrNone' | 'MarkPrice' | 'IndexPrice' | 'LastPrice' | 'Close' | 'ReduceOnly' | 'Fixed' | 'LastWithinMark';
    /**
     * Optional contingency type for use with `clOrdLinkID`. Valid options: OneCancelsTheOther, OneTriggersTheOther.
     */
    contingencyType?: 'OneCancelsTheOther' | 'OneTriggersTheOther';
    /**
     * Optional order annotation. e.g. 'Take profit'.
     */
    text?: string;
}
export interface OrderPut {
    /**
     * Order ID
     */
    orderID?: string;
    /**
     * Client Order ID. See POST /order.
     */
    origClOrdID?: string;
    /**
     * Optional new Client Order ID, requires `origClOrdID`.
     */
    clOrdID?: string;
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;
    /**
     * Optional order quantity in units of the instrument (i.e. contracts, for spot it is the base currency in minor currency (e.g. XBt quantity for XBT)).
     */
    orderQty?: number;
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleLeavesQty?: number;
    /**
     * Optional leaves quantity in units of the instrument (i.e. contracts, for spot it is the base currency in minor currency (e.g. XBt quantity for XBT)). Useful for amending partially filled orders.
     */
    leavesQty?: number;
    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;
    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders.
     */
    stopPx?: number;
    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;
    /**
     * Optional amend annotation. e.g. 'Adjust skew'.
     */
    text?: string;
}
export interface OrderDelete {
    /**
     * Order ID(s).
     */
    orderID?: string;
    /**
     * Client Order ID(s). See POST /order.
     */
    clOrdID?: string;
    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'.
     */
    text?: string;
}
export interface OrderClosePositionPost {
    /**
     * Symbol of position to close.
     */
    symbol: string;
    /**
     * Optional limit price.
     */
    price?: number;
}
export interface OrderAllDelete {
    /**
     * AccountIds to cancel all orders, must be a paired account with main user. Also accepts wildcard, [*], this will cancel all orders for all accounts. the authenticated user has order write permissions for.
     */
    targetAccountIds?: string;
    /**
     * Optional symbol. If provided, only cancels orders for that symbol.
     */
    symbol?: string;
    /**
     * Optional filter for cancellation. Use to only cancel some orders, e.g. `{"side": "Buy"}`.
     */
    filter?: string;
    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'
     */
    text?: string;
}
export interface OrderCancelAllAfterPost {
    /**
     * Timeout in ms. Set to 0 to cancel this timer.
     */
    timeout: number;
}
export interface OrderBookL2Query {
    /**
     * Instrument symbol. Send a series (e.g. XBT) to get data for the nearest contract in that series.
     */
    symbol: string;
    /**
     * Orderbook depth per side. Send 0 for full depth.
     */
    depth?: number;
}
export interface PositionQuery {
    /**
     * Table filter. For example, send {"symbol": "XBTUSD"}.
     */
    filter?: string;
    /**
     * Which columns to fetch. For example, send ["columnName"].
     */
    columns?: string;
    /**
     * Number of rows to fetch.
     */
    count?: number;
}
export interface PositionIsolatePost {
    /**
     * Position symbol to isolate.
     */
    symbol: string;
    /**
     * True for isolated margin, false for cross margin.
     */
    enabled?: boolean;
}
export interface PositionRiskLimitPost {
    /**
     * Symbol of position to update risk limit on.
     */
    symbol: string;
    /**
     * New Risk Limit, in Satoshis.
     */
    riskLimit: number;
    /**
     * AccountId for the position that the risk limit would be updated on, must be a paired account with main user.
     */
    targetAccountId?: number;
}
export interface PositionTransferMarginPost {
    /**
     * Symbol of position to isolate.
     */
    symbol: string;
    /**
     * Amount to transfer, in Satoshis. May be negative.
     */
    amount: number;
    /**
     * AccountId for the position that the margin would be transfered to, must be a paired account with main user.
     */
    targetAccountId?: number;
}
export interface PositionLeveragePost {
    /**
     * Symbol of position to adjust.
     */
    symbol: string;
    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;
    /**
     * AccountId for the position that the leverage would be changed on, must be a paired account with main user.
     */
    targetAccountId?: number;
}
export interface PositionCrossLeveragePost {
    /**
     * Symbol of position to adjust.
     */
    symbol: string;
    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;
    /**
     * AccountId for the position that the leverage would be changed on, must be a paired account with main user.
     */
    targetAccountId?: number;
}
export interface QuoteQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface QuoteBucketedQuery {
    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d';
    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean;
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface SchemaQuery {
    /**
     * Optional model filter. If omitted, will return all models.
     */
    model?: string;
}
export interface SettlementQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface TradeQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface TradeBucketedQuery {
    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d';
    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean;
    /**
     * Instrument symbol. Send a bare series (e.g. XBT) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBT:quarterly`. Timeframes are `nearest`, `daily`, `weekly`, `monthly`, `quarterly`, `biquarterly`, and `perpetual`.
     *
     * Symbols are case-insensitive.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch. Must be a positive integer.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface UserDepositAddressQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;
    /**
     * The `network` parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /wallet/assets`.
     */
    network: string;
}
export interface UserDepositAddressInformationQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;
    /**
     * The `network` parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /wallet/assets`.
     */
    network: string;
}
export interface UserWalletQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string;
}
export interface UserWalletHistoryQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string;
    /**
     * Number of results to fetch. Fetch results from start to start + count. Max: 10,000 rows.
     */
    count?: number;
    /**
     * Starting point for results, integer. Default 0.
     */
    start?: number;
    /**
     * AccountId to view the history of, must be a paired account with the authorised user requesting the history.
     */
    targetAccountId?: number;
    /**
     * Start from the latest transaction record. Default true.
     */
    reverse?: boolean;
}
export interface UserWalletSummaryQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string;
    /**
     * Start time for the summary
     */
    startTime?: string;
    /**
     * End time for the summary
     */
    endTime?: string;
}
export interface UserExecutionHistoryQuery {
    symbol?: string;
    timestamp?: string;
}
export interface UserStakingQuery {
    currency?: string;
}
export interface UserUnstakingRequestsQuery {
    status: string;
}
export interface UserUnstakingRequestsPost {
    symbol: string;
    amount: number;
}
export interface UserUnstakingRequestsDelete {
    redemptionID: string;
}
export interface UserStakingInstrumentsQuery {
    symbol?: string;
    currency?: string;
}
export interface UserStakingTiersQuery {
    currency: string;
}
export interface UserWalletTransferPost {
    /**
     * Currency you're transfering. Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency: string;
    /**
     * Amount of transfer.
     */
    amount: number;
    /**
     * AccountID to send the transfer from. Must be paired account with the authenticated user.
     */
    fromAccountId?: number;
    /**
     * AccountId to send the transfer to, must be a paired account with the user sending the transfer.
     */
    targetAccountId: number;
}
export interface UserRequestWithdrawalPost {
    /**
     * 2FA token. Required for all external withdrawals unless the destination is a saved address with `skip2FA` configured.
     */
    otpToken?: string;
    /**
     * Currency you're withdrawing. Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>
     */
    currency?: string;
    /**
     * The `network` parameter is used to indicate which blockchain you would like to withdraw from. The acceptable value in the `network` parameter for each currency can be found from `networks.asset` from `GET /api/v1/wallet/assets`.
     */
    network: string;
    /**
     * Amount of withdrawal currency.
     */
    amount: number;
    /**
     * Destination Address. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    address?: string;
    /**
     * Destination Memo. If `address`, is specified, destination Memo can also be specified. If given an `addressId` or `address` matching a saved address, the destination memo from the saved address will be used.
     */
    memo?: string;
    /**
     * ID of the Destination Address. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    addressId?: number;
    /**
     * ID of a linked BitMEX account. One of `address`, `addressId`, `targetUserId` has to be specified.
     */
    targetUserId?: number;
    /**
     * Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email.
     */
    fee?: number;
    /**
     * Optional annotation, e.g. 'Transfer to home wallet'.
     */
    text?: string;
}
export interface UserWithdrawalDelete {
    transactID: string;
}
export interface UserCancelWithdrawalPost {
    token: string;
}
export interface UserConfirmWithdrawalPost {
    token: string;
}
export interface UserConfirmEmailPost {
    token: string;
}
export interface UserAffiliateStatusQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string;
}
export interface UserCheckReferralCodeQuery {
    referralCode?: string;
}
export interface UserQuoteFillRatioQuery {
    /**
     * AccountId to get quote fill ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountId?: number;
}
export interface UserQuoteValueRatioQuery {
    /**
     * AccountId to get quote value ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user
     */
    targetAccountId?: number;
}
export interface UserAddSubaccountPost {
    accountName: string;
}
export interface UserCreateIndependentSubaccountPost {
    email: string;
    accountName: string;
}
export interface UserUpdateSubaccountPost {
    targetAccountId: number;
    accountName: string;
}
export interface UserPreferencesPost {
    prefs: string;
    /**
     * If true, will overwrite all existing preferences.
     */
    overwrite?: boolean;
}
export interface UserMarginingModePost {
    /**
     * AccountId to update the margining mode of.
     */
    targetAccountId?: number;
    /**
     * Margining mode. Provide the value MultiAsset for multi-asset margining. Leave the field empty for single-asset margining
     */
    marginingMode?: string;
}
export interface UserMarginQuery {
    /**
     * Any currency. For all currencies, see <a href="#!/Wallet/Wallet_getAssetsConfig">asset config endpoint</a>. For all currencies specify "all"
     */
    currency?: string;
}
export interface UserCommunicationTokenPost {
    token: string;
    platformAgent: string;
}
export interface UserEventQuery {
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Cursor for pagination.
     */
    startId?: number;
}
export interface AddressPost {
    /**
     * Currency of the address. Options: `XBt`, `USDt`
     */
    currency?: 'XBt' | 'USDt';
    /**
     * Selected network.
     */
    network: string;
    /**
     * Destination Address.
     */
    address: string;
    /**
     * Name of the entry, eg. 'Hardware wallet'.
     */
    name: string;
    /**
     * Optional annotation.
     */
    note?: string;
    /**
     * Skip e-mail confirmations for transfers to this address. An email will be sent for confirmation to verify this setting.
     */
    skipConfirm?: boolean;
    /**
     * Skip 2FA confirmations for transfers to this address. If otpToken is not provided in this request, an email will be sent to capture 2FA and verify this setting.
     */
    skip2FA?: boolean;
    /**
     * Destination Memo.
     */
    memo?: string;
    /**
     * 2FA token. Provide to verify skip2FA or to start the cooldown period on address with whitelist setting enabled. If not provided, an email will be sent to capture 2FA.
     */
    otpToken?: string;
}
export interface UserAffiliatesQuery {
    /**
     * the depth of affiliates to return. Eg depth = 2 would return direct affiliates and their affiliates
     */
    depth?: number;
    /**
     * AccountId of Sub-Affiliate Account
     */
    targetAccountId?: number;
    /**
     * User id of result array to keep
     */
    selectUserId?: number;
}
export interface GuildPost {
    /**
     * Name of the guild, must be unique, must be at least 5 characters
     */
    name: string;
    /**
     * Emoji name.
     */
    emoji: string;
    /**
     * How much of the pot should be distributed to the guild members, must be between 0 and 100
     */
    potDistributionPercent: number;
    /**
     * How the pot should be distributed to the guild members, must be one of the following: ROLL_OVER, TOP_3, TOP_5, TOP_10, VOLUME_PERCENTAGE, TOP_3_BY_ADV, TOP_5_BY_ADV, TOP_10_BY_ADV, TOP_3_BY_ROI, TOP_5_BY_ROI, TOP_10_BY_ROI, RANDOM
     */
    potDistributionType: string;
    /**
     * Guild description, can be used to explain the guild to other users.
     */
    description?: string;
    /**
     * Guild twitter handle.
     */
    twitter?: string;
    /**
     * Guild discord link.
     */
    discord?: string;
    /**
     * Guild telegram link.
     */
    telegram?: string;
    /**
     * URL for the profile image of the guild, is used by clients to add some color to the guild, if no image is provided, a default image is used
     */
    imgUrl?: string;
    /**
     * Guild privacy status
     */
    isPrivate?: boolean;
}
export interface GuildPut {
    /**
     * Name of the guild, must be unique, must be at least 5 characters
     */
    name: string;
    /**
     * Emoji name.
     */
    emoji: string;
    /**
     * How much of the pot should be distributed to the guild members, must be between 0 and 100
     */
    potDistributionPercent: number;
    /**
     * How the pot should be distributed to the guild members, must be one of the following: ROLL_OVER, TOP_3, TOP_5, TOP_10, VOLUME_PERCENTAGE, TOP_3_BY_ADV, TOP_5_BY_ADV, TOP_10_BY_ADV, TOP_3_BY_ROI, TOP_5_BY_ROI, TOP_10_BY_ROI, RANDOM
     */
    potDistributionType: string;
    /**
     * User ID of the guild member with order write permission for the pot
     */
    potTraderId?: number;
    /**
     * Guild description, can be used to explain the guild to other users.
     */
    description?: string;
    /**
     * Guild twitter handle.
     */
    twitter?: string;
    /**
     * Guild discord link.
     */
    discord?: string;
    /**
     * Guild telegram link.
     */
    telegram?: string;
    /**
     * URL for the profile image of the guild, is used by clients to add some color to the guild, if no image is provided, a default image is used
     */
    imgUrl?: string;
    /**
     * Guild privacy status
     */
    isPrivate?: boolean;
}
export interface GuildShareTradesPost {
    shareTrades: boolean;
}
export interface GuildKickPost {
    memberUserId: number;
}
export interface GuildJoinPost {
    code: string;
}
export interface ReferralCodePost {
    data: undefined;
}
export interface ReferralCodeCheckGet {
    code: string;
}
export interface ReferralCodePut {
    id: number;
    data: undefined;
}
export interface ReferralCodeDelete {
    id: number;
}
export interface ReferralCodeGet {
    id: number;
}
